> **Disclaimer:** This document was generated by an AI assistant.

# Iced User Guide

Welcome to the user guide for **Iced**, a cross-platform GUI library for Rust focused on simplicity and type-safety. Iced is inspired by [Elm](https://elm-lang.org/) and The Elm Architecture.

## Table of Contents

1.  [Introduction](#introduction)
2.  [Getting Started](#getting-started)
3.  [The Elm Architecture](#the-elm-architecture)
4.  [Your First Application: Counter](#your-first-application-counter)
5.  [Widgets](#widgets)
    - [Common Inputs](#common-inputs)
    - [Layout & Containers](#layout--containers)
    - [Display](#display)
    - [Complex Inputs](#complex-inputs)
6.  [Core Concepts](#core-concepts)
    - [Layout & Positioning](#layout--positioning)
    - [Async Actions (Commands/Tasks)](#async-actions-commands)
    - [Subscriptions](#subscriptions)
7.  [Advanced Styling & Theming](#advanced-styling--theming)
8.  [Advanced Graphics](#advanced-graphics)
    - [Canvas](#canvas)
    - [Shaders](#shaders)
9.  [Custom Widgets](#custom-widgets)
10. [Performance Optimization](#performance-optimization)
11. [Application Lifecycle & Windowing](#application-lifecycle--windowing)
12. [Web Deployment](#web-deployment)
13. [Testing & Debugging](#testing--debugging)

---

## Introduction

Iced allows you to build applications for Windows, macOS, Linux, and the Web using a type-safe, reactive programming model.

Key features:

- **Simple API**: Easy to learn and use.
- **Type-Safe**: Leverages Rust's type system to prevent runtime errors.
- **Cross-Platform**: Write once, run anywhere.
- **Batteries-Included**: Comes with a rich set of built-in widgets.

## Getting Started

### Prerequisites

Ensure you have [Rust](https://www.rust-lang.org/tools/install) installed.

### Installation

Add `iced` to your `Cargo.toml` dependencies:

```toml
[dependencies]
iced = "0.13" # Check crates.io for the latest version
```

If you want to use specific renderers or features, you can enable them:

```toml
[dependencies]
iced = { version = "0.13", features = ["wgpu", "canvas", "advanced"] }
```

## The Elm Architecture

Iced follows The Elm Architecture, which separates your application into four distinct parts:

1.  **State**: The data that describes your application at a given point in time.
2.  **Messages**: Enums representing user interactions or events (e.g., `ButtonPressed`, `TextChanged`).
3.  **View Logic**: A function that turns your **State** into a visual interface (Widgets). It produces **Messages** when users interact with it.
4.  **Update Logic**: A function that takes a **Message** and the current **State**, and updates the **State**.

## Your First Application: Counter

Let's build a simple counter application to understand how these pieces fit together.

### 1. Define the State

First, describe the state of your application. For a counter, we just need an integer.

```rust
use iced::widget::{button, column, text, Column};
use iced::Center;

#[derive(Default)]
struct Counter {
    value: i32,
}
```

### 2. Define Messages

Next, define the possible interactions. The user can increment or decrement the counter.

```rust
#[derive(Debug, Clone, Copy)]
pub enum Message {
    Increment,
    Decrement,
}
```

### 3. Implement View Logic

Now, define how the UI looks based on the state. We'll use a `Column` to stack a button, the value text, and another button.

```rust
impl Counter {
    pub fn view(&self) -> Column<Message> {
        column![
            button("Increment").on_press(Message::Increment),
            text(self.value).size(50),
            button("Decrement").on_press(Message::Decrement),
        ]
        .padding(20)
        .align_x(Center)
    }
}
```

### 4. Implement Update Logic

Define how the state changes in response to messages.

```rust
impl Counter {
    pub fn update(&mut self, message: Message) {
        match message {
            Message::Increment => {
                self.value += 1;
            }
            Message::Decrement => {
                self.value -= 1;
            }
        }
    }
}
```

### 5. Run the Application

Finally, wire everything together using `iced::run`.

```rust
pub fn main() -> iced::Result {
    iced::run("Counter", Counter::update, Counter::view)
}
```

## Widgets

Iced provides a wide variety of widgets. All widgets are available in the `iced::widget` module.

### Common Inputs

#### Button

A generic widget that produces a message when pressed.

**API:**

- `new(content: impl Into<Element>) -> Self`
- `on_press(message: Message) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `height(height: impl Into<Length>) -> Self`
- `padding(padding: impl Into<Padding>) -> Self`
- `style(f: impl Fn(&Theme, Status) -> Style) -> Self`

```rust
button("Click Me").on_press(Message::ButtonPressed)
```

#### TextInput

A field that can be filled with text.

**API:**

- `new(placeholder: &str, value: &str) -> Self`
- `on_input(f: impl Fn(String) -> Message) -> Self`
- `on_submit(message: Message) -> Self`
- `secure(is_secure: bool) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `padding(padding: impl Into<Padding>) -> Self`

```rust
text_input("Placeholder", &self.content).on_input(Message::ContentChanged)
```

#### Checkbox

A box that can be checked.

**API:**

- `new(is_checked: bool) -> Self`
- `label(label: impl IntoFragment) -> Self`
- `on_toggle(f: impl Fn(bool) -> Message) -> Self`

```rust
checkbox("Enable", self.is_enabled).on_toggle(Message::Toggled)
```

#### Slider

A horizontal bar and a handle that selects a single value from a range.

**API:**

- `new(range: RangeInclusive<T>, value: T, on_change: impl Fn(T) -> Message) -> Self`
- `step(step: impl Into<T>) -> Self`
- `width(width: impl Into<Length>) -> Self`

```rust
slider(0.0..=100.0, self.value, Message::ValueChanged).step(1.0)
```

#### PickList

Select an option from a dropdown list.

**API:**

- `new(options: impl Borrow<[T]>, selected: Option<T>, on_select: impl Fn(T) -> Message) -> Self`
- `placeholder(placeholder: impl Into<String>) -> Self`

```rust
pick_list(&self.options, Some(self.selected), Message::Selected)
```

### Layout & Containers

#### Column

Arranges children vertically.

**API:**

- `new() -> Self`
- `push(child: impl Into<Element>) -> Self`
- `spacing(amount: impl Into<Pixels>) -> Self`
- `padding(padding: impl Into<Padding>) -> Self`
- `align_x(alignment: impl Into<Horizontal>) -> Self`

```rust
column![text("Item 1"), text("Item 2")].spacing(10)
```

#### Row

Arranges children horizontally.

**API:**

- `new() -> Self`
- `push(child: impl Into<Element>) -> Self`
- `spacing(amount: impl Into<Pixels>) -> Self`
- `padding(padding: impl Into<Padding>) -> Self`
- `align_y(alignment: impl Into<Vertical>) -> Self`

```rust
row![text("Item 1"), text("Item 2")].spacing(10)
```

#### Container

Wraps a single widget to provide padding, alignment, and styling.

**API:**

- `new(content: impl Into<Element>) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `height(height: impl Into<Length>) -> Self`
- `center_x(width: impl Into<Length>) -> Self`
- `center_y(height: impl Into<Length>) -> Self`
- `style(f: impl Fn(&Theme) -> Style) -> Self`

```rust
container(text("Content")).center(Length::Fill)
```

#### Scrollable

Allows content to scroll if it overflows.

**API:**

- `new(content: impl Into<Element>) -> Self`
- `direction(direction: impl Into<Direction>) -> Self`
- `on_scroll(f: impl Fn(Viewport) -> Message) -> Self`

```rust
scrollable(column![...]).height(Length::Fill)
```

### Display

#### Text

Displays immutable text.

**API:**

- `new(content: impl Into<String>) -> Self`
- `size(size: impl Into<Pixels>) -> Self`
- `color(color: impl Into<Color>) -> Self`
- `font(font: impl Into<Font>) -> Self`

```rust
text("Hello World").size(24)
```

#### Image

Displays a raster image.

**API:**

- `new(handle: impl Into<Handle>) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `content_fit(fit: ContentFit) -> Self`

```rust
image("path/to/image.png")
```

### Complex Inputs

#### TextEditor

A multi-line text editor with highlighting support.

**API:**

- `new(content: &Content) -> Self`
- `on_action(f: impl Fn(Action) -> Message) -> Self`
- `highlight(extension: &str, theme: highlighter::Theme) -> Self`

```rust
text_editor(&self.content).on_action(Message::EditorAction)
```

## Core Concepts

### Layout & Positioning

Iced uses a flexible layout system based on `Length`:

- **`Length::Shrink`**: Fits the content size.
- **`Length::Fill`**: Fills available space.
- **`Length::Fixed(f32)`**: Exact size in pixels.
- **`Length::FillPortion(u16)`**: Weighted distribution in `Row`/`Column`.

### Async Actions (Commands)

Your `update` function returns a `Task` (formerly `Command`). This allows you to perform asynchronous operations like HTTP requests, file I/O, or timers without freezing the UI.

```rust
fn update(&mut self, message: Message) -> Task<Message> {
    match message {
        Message::LoadData => Task::perform(fetch_data(), Message::DataLoaded),
        Message::DataLoaded(data) => { /* ... */ Task::none() }
    }
}
```

### Subscriptions

Subscriptions allow your application to listen to external events continuously (keyboard, mouse, window resizing).

```rust
fn subscription(&self) -> Subscription<Message> {
    use iced::keyboard;
    keyboard::on_key_press(|key, modifiers| Some(Message::KeyPressed(key)))
}
```

## Advanced Styling & Theming

Iced uses a `Theme` enum for global styling. You can pick from built-in themes (like `Theme::Dark`, `Theme::Light`, `Theme::Dracula`) or define your own.

### Built-in Styles

Most widgets come with style constructors that take the current theme:

```rust
button("Delete").style(button::danger)
```

### Custom Styling

To create custom styles, you typically define a function that returns a style struct (e.g., `button::Style`, `container::Style`) based on the `Theme` and widget `Status`.

```rust
fn custom_button_style(theme: &Theme, status: button::Status) -> button::Style {
    let base = button::Style::default();
    match status {
        button::Status::Active => base.with_background(Color::from_rgb(0.1, 0.5, 0.9)),
        button::Status::Hovered => base.with_background(Color::from_rgb(0.2, 0.6, 1.0)),
        _ => base,
    }
}

// Usage
button("Custom").style(custom_button_style)
```

## Advanced Graphics

### Canvas

For custom 2D vector graphics, use the `Canvas` widget. You must implement the `canvas::Program` trait.

```rust
use iced::widget::canvas;

struct MyProgram;

impl canvas::Program<Message> for MyProgram {
    type State = ();

    fn draw(&self, _state: &(), renderer: &Renderer, _theme: &Theme, bounds: Rectangle, _cursor: mouse::Cursor) -> Vec<canvas::Geometry> {
        let mut frame = canvas::Frame::new(renderer, bounds.size());
        frame.fill_rectangle(Point::ORIGIN, Size::new(50.0, 50.0), Color::BLACK);
        vec![frame.into_geometry()]
    }
}

// View
canvas(MyProgram).width(Length::Fill).height(Length::Fill)
```

### Shaders

For maximum performance or custom effects, you can write custom WGSL shaders using the `shader` widget (requires `wgpu` feature). See `examples/custom_shader`.

## Custom Widgets

If `Canvas` isn't enough (e.g., you need complex layout logic or child widgets), you can implement the `Widget` trait directly.

Key methods to implement:

- **`size`**: Return the widget's width and height.
- **`layout`**: Calculate layout nodes for the widget and its children.
- **`draw`**: Issue drawing commands to the renderer.
- **`update`**: Handle events and update internal state.
- **`mouse_interaction`**: Define cursor changes (e.g., grab, pointer).

See `examples/custom_widget` for a complete boilerplate.

## Performance Optimization

### `lazy`

The `lazy` widget is crucial for performance in large lists. It caches the widget tree and only rebuilds it if the input data changes.

```rust
use iced::widget::lazy;

// Only re-renders 'view_large_list' if 'self.items' changes (based on hash/eq)
lazy(&self.items, |items| view_large_list(items))
```

### `keyed`

Helpers like `column` or `row` can be expensive if items are inserted/removed frequently. While Iced is fast, using keyed structures (often manual implementation or specialized crates) helps preserve state.

## Application Lifecycle & Windowing

### Multi-Window

Use `iced::daemon` instead of `iced::application` for advanced control, including managing multiple windows.

```rust
fn main() -> iced::Result {
    iced::daemon(App::new, App::update, App::view)
        .run()
}
```

Messages for window management:

- `window::open`: Spawns a new window.
- `window::close`: Closes a specific window.
- `window::resize`: Resizes a window programmatically.

### Application Exit

To exit the application gracefully, call `iced::exit()`, which returns a `Task` that closes the loop.

## Web Deployment

Iced supports compiling to WebAssembly (WASM).

1.  Install the target: `rustup target add wasm32-unknown-unknown`.
2.  Use a tool like `trunk` to bundle your app.
3.  Ensure your `Task`s are compatible with WASM (e.g., use `reqwest` with `json` feature for fetch, avoid blocking IO).

## Testing & Debugging

### Debug Overlay

You can enable a debug overlay to inspect widget boundaries and performance metrics. This is often a feature flag or a runtime setting depending on the specific Iced version/renderer setup.

### Testing

Since `update` functions are pure (State + Message -> State + Task), they are easy to unit test.

```rust
#[test]
fn test_increment() {
    let mut counter = Counter::default();
    counter.update(Message::Increment);
    assert_eq!(counter.value, 1);
}
```

For integration testing (simulating user interaction), use `iced_test` if available or structure your logic to decouple it from the view entirely.

cs.rs/iced) or the [Iced Book](https://book.iced.rs/).
