> **Disclaimer:** This document was generated by an AI assistant

# Iced User Guide

Welcome to the user guide for **Iced**, a cross-platform GUI library for Rust focused on simplicity and type-safety. Iced is inspired by [Elm](https://elm-lang.org/) and The Elm Architecture.

## Table of Contents

1.  [Introduction](#introduction)
2.  [Getting Started](#getting-started)
3.  [The Elm Architecture](#the-elm-architecture)
4.  [Your First Application: Counter](#your-first-application-counter)
5.  [Widgets](#widgets)
    - [Common Inputs](#common-inputs)
    - [Layout & Containers](#layout--containers)
    - [Display](#display)
    - [Advanced Widgets](#advanced-widgets)
6.  [Core Concepts](#core-concepts)
    - [Layout & Positioning](#layout--positioning)
    - [Styling](#styling)
    - [Async Actions (Commands)](#async-actions-commands)
    - [Subscriptions](#subscriptions)
7.  [Running Examples](#running-examples)

---

## Introduction

Iced allows you to build applications for Windows, macOS, Linux, and the Web using a type-safe, reactive programming model.

Key features:

- **Simple API**: Easy to learn and use.
- **Type-Safe**: Leverages Rust's type system to prevent runtime errors.
- **Cross-Platform**: Write once, run anywhere.
- **Batteries-Included**: Comes with a rich set of built-in widgets.

## Getting Started

### Prerequisites

Ensure you have [Rust](https://www.rust-lang.org/tools/install) installed.

### Installation

Add `iced` to your `Cargo.toml` dependencies:

```toml
[dependencies]
iced = "0.13" # Check crates.io for the latest version
```

If you want to use specific renderers or features, you can enable them:

```toml
[dependencies]
iced = { version = "0.13", features = ["wgpu"] }
```

## The Elm Architecture

Iced follows The Elm Architecture, which separates your application into four distinct parts:

1.  **State**: The data that describes your application at a given point in time.
2.  **Messages**: Enums representing user interactions or events (e.g., `ButtonPressed`, `TextChanged`).
3.  **View Logic**: A function that turns your **State** into a visual interface (Widgets). It produces **Messages** when users interact with it.
4.  **Update Logic**: A function that takes a **Message** and the current **State**, and updates the **State**.

## Your First Application: Counter

Let's build a simple counter application to understand how these pieces fit together.

### 1. Define the State

First, describe the state of your application. For a counter, we just need an integer.

```rust
use iced::widget::{button, column, text, Column};
use iced::Center;

#[derive(Default)]
struct Counter {
    value: i32,
}
```

### 2. Define Messages

Next, define the possible interactions. The user can increment or decrement the counter.

```rust
#[derive(Debug, Clone, Copy)]
pub enum Message {
    Increment,
    Decrement,
}
```

### 3. Implement View Logic

Now, define how the UI looks based on the state. We'll use a `Column` to stack a button, the value text, and another button.

```rust
impl Counter {
    pub fn view(&self) -> Column<Message> {
        column![
            button("Increment").on_press(Message::Increment),
            text(self.value).size(50),
            button("Decrement").on_press(Message::Decrement),
        ]
        .padding(20)
        .align_x(Center)
    }
}
```

### 4. Implement Update Logic

Define how the state changes in response to messages.

```rust
impl Counter {
    pub fn update(&mut self, message: Message) {
        match message {
            Message::Increment => {
                self.value += 1;
            }
            Message::Decrement => {
                self.value -= 1;
            }
        }
    }
}
```

### 5. Run the Application

Finally, wire everything together using `iced::run`.

```rust
pub fn main() -> iced::Result {
    iced::run("Counter", Counter::update, Counter::view)
}
```

Note: `iced::run` is a simplified way to run an application. For more control (like setting the window title, custom fonts, or window settings), use `iced::application`:

```rust
pub fn main() -> iced::Result {
    iced::application(Counter::default, Counter::update, Counter::view)
        .title(|_state| String::from("Counter"))
        .run()
}
```

## Widgets

Iced provides a wide variety of widgets. All widgets are available in the `iced::widget` module.

### Common Inputs

#### Button

Triggers a message when pressed.

```rust
use iced::widget::button;

button("Click Me")
    .on_press(Message::ButtonPressed)
    .padding(10)
```

#### TextInput

Allows single-line text entry.

```rust
use iced::widget::text_input;

text_input("Placeholder", &self.content)
    .on_input(Message::ContentChanged)
    .padding(10)
```

#### Checkbox

A boolean toggle.

```rust
use iced::widget::checkbox;

checkbox("Enable feature", self.is_enabled)
    .on_toggle(Message::FeatureToggled)
```

#### Radio

Select one option from a set.

```rust
use iced::widget::radio;

radio(
    "Option A",
    MyEnum::OptionA,
    Some(self.selected_option),
    Message::OptionSelected
)
```

#### Toggler

A switch-like toggle.

```rust
use iced::widget::toggler;

toggler(self.is_active)
    .label("Activate")
    .on_toggle(Message::Toggled)
```

#### Slider

Select a value from a range.

```rust
use iced::widget::slider;

slider(0.0..=100.0, self.value, Message::ValueChanged)
    .step(1.0)
```

#### PickList

Select an option from a dropdown list.

```rust
use iced::widget::pick_list;

// 'options' is a slice of values, e.g., &self.options
pick_list(options, Some(self.selected_option), Message::OptionSelected)
```

#### ComboBox

Select an option with search/filtering capabilities.

```rust
use iced::widget::combo_box;

combo_box(
    &self.combo_box_state,
    "Type to search...",
    Some(&self.selected_item),
    Message::ItemSelected
)
```

### Layout & Containers

#### Column

Arranges children vertically.

```rust
use iced::widget::column;

column![
    text("First item"),
    text("Second item"),
]
.spacing(20)
.padding(10)
```

#### Row

Arranges children horizontally.

```rust
use iced::widget::row;

row![
    text("Left"),
    text("Right"),
]
.spacing(20)
```

#### Container

Wraps a single widget to provide padding, alignment, and styling.

```rust
use iced::widget::container;
use iced::{Center, Length};

container(text("Centered Content"))
    .width(Length::Fill)
    .height(Length::Fill)
    .align_x(Center)
    .align_y(Center)
```

#### Scrollable

Allows content to scroll if it overflows.

```rust
use iced::widget::scrollable;

scrollable(
    column![
        // ... lots of content ...
    ]
)
```

#### Space

A void element, useful for filling empty space or creating flexible gaps.

```rust
use iced::widget::{row, space, text};
use iced::Length;

row![
    text("Left"),
    space().width(Length::Fill), // Pushes "Right" to the far end
    text("Right")
]
```

### Display

#### Text

Displays immutable text.

```rust
use iced::widget::text;

text("Hello World")
    .size(20)
    .color([0.5, 0.5, 0.5])
```

#### Image

Displays a raster image (PNG, JPG, etc.).

```rust
use iced::widget::image;

image("path/to/image.png")
    .width(300)
```

#### Svg

Displays a vector graphic.

```rust
use iced::widget::svg;

svg("path/to/image.svg")
    .width(Length::Fill)
    .height(Length::Fill)
```

#### Tooltip

Shows a popup when hovering over a widget.

```rust
use iced::widget::tooltip;

tooltip(
    text("Hover me"),
    "This is the tooltip content",
    tooltip::Position::Top
)
```

#### ProgressBar

Visualizes progress.

```rust
use iced::widget::progress_bar;

progress_bar(0.0..=100.0, self.progress)
```

#### Rule

Draws a horizontal or vertical line divider.

```rust
use iced::widget::rule;

rule::horizontal(10) // 10 pixels of spacing
```

### Advanced Widgets

#### Canvas

For drawing custom 2D graphics (shapes, paths, transforms).
Requires implementing `canvas::Program`.

```rust
use iced::widget::canvas;

canvas(self.program)
    .width(Length::Fill)
    .height(Length::Fill)
```

#### PaneGrid

A layout that allows splitting the window into multiple resizable panes.
See `examples/pane_grid` for a full implementation.

#### Markdown

Renders Markdown text. Requires the `markdown` feature.

```rust
use iced::widget::markdown;

markdown(
    "# Title\n**Bold text**",
    self.markdown_settings,
    self.markdown_style
)
```

## Core Concepts

### Layout & Positioning

Iced uses a flexible layout system based on specific length units.

- **Length::Shrink**: The widget will be as small as possible to fit its content. (Default for most widgets).
- **Length::Fill**: The widget will fill all available space.
- **Length::Fixed(f32)**: The widget will have a specific size in logical pixels.
- **Length::FillPortion(u16)**: Used in `Row` or `Column` to distribute weighted space (e.g., 2 portions vs 1 portion).

#### Alignment

`Row` and `Column` have `.align_items()` (cross-axis alignment).
`Container` has `.align_x()` and `.align_y()`.

### Styling

Iced supports theming. You can switch between built-in themes or define your own.

```rust
// In your application setup:
.theme(|state| Theme::Dark)
```

Widgets often accept a styling function or a style object to customize their appearance beyond the theme defaults.

```rust
button("Danger").style(button::danger)
```

### Async Actions (Commands)

Your `update` function returns a `Task` (formerly `Command`). This allows you to perform asynchronous operations like HTTP requests, file I/O, or timers without freezing the UI.

```rust
// In your State
fn update(&mut self, message: Message) -> Task<Message> {
    match message {
        Message::FetchData => {
            // Returns a Task that will produce a message when done
            Task::perform(fetch_url(), Message::DataFetched)
        }
        Message::DataFetched(result) => {
            // Handle result
            Task::none()
        }
    }
}

async fn fetch_url() -> Result<String, Error> {
    // ... async code ...
}
```

### Subscriptions

Subscriptions allow your application to listen to external events (keyboard, mouse, time, window resizing) continuously.

```rust
fn subscription(&self) -> Subscription<Message> {
    use iced::{keyboard, time};

    Subscription::batch(vec![
        keyboard::on_key_press(|key, modifiers| {
            Some(Message::KeyPressed(key))
        }),
        time::every(std::time::Duration::from_secs(1)).map(|_| Message::Tick),
    ])
}
```

## Running Examples

The `iced` repository contains many examples demonstrating different features. To run them, clone the repository and use `cargo run`.

```bash
git clone https://github.com/iced-rs/iced.git
cd iced
cargo run --example counter
cargo run --example tour
cargo run --example todos
```

Explore the `examples/` directory to see how to implement more advanced features like:

- **Styling**: `examples/styling`
- **Async Actions**: `examples/download_progress`
- **Custom Widgets**: `examples/custom_widget`
- **Canvas/Drawing**: `examples/solar_system`
- **Pane Grid**: `examples/pane_grid`

---

For more detailed documentation, visit [docs.rs/iced](https://docs.rs/iced) or the [Iced Book](https://book.iced.rs/).
