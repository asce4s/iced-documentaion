> **Disclaimer:** This document was generated by an AI assistant.

# Iced User Guide

Welcome to the user guide for **Iced**, a cross-platform GUI library for Rust focused on simplicity and type-safety. Iced is inspired by [Elm](https://elm-lang.org/) and The Elm Architecture.

## Table of Contents

1.  [Introduction](#introduction)
2.  [Getting Started](#getting-started)
3.  [The Elm Architecture](#the-elm-architecture)
4.  [Your First Application: Counter](#your-first-application-counter)
5.  [Widgets](#widgets)
    - [Common Inputs](#common-inputs)
    - [Layout & Containers](#layout--containers)
    - [Display](#display)
    - [Complex Inputs](#complex-inputs)
    - [Utility Widgets](#utility-widgets)
6.  [Core Concepts](#core-concepts)
    - [Layout & Positioning](#layout--positioning)
    - [Async Actions (Commands/Tasks)](#async-actions-commands)
    - [Subscriptions](#subscriptions)
7.  [Advanced Styling & Theming](#advanced-styling--theming)
8.  [Advanced Graphics](#advanced-graphics)
    - [Canvas](#canvas)
    - [Shaders](#shaders)
9.  [Custom Widgets](#custom-widgets)
10. [Performance Optimization](#performance-optimization)
11. [Application Lifecycle & Windowing](#application-lifecycle--windowing)
12. [Web Deployment](#web-deployment)
13. [Testing & Debugging](#testing--debugging)

---

## Introduction

Iced allows you to build applications for Windows, macOS, Linux, and the Web using a type-safe, reactive programming model.

Key features:

- **Simple API**: Easy to learn and use.
- **Type-Safe**: Leverages Rust's type system to prevent runtime errors.
- **Cross-Platform**: Write once, run anywhere.
- **Batteries-Included**: Comes with a rich set of built-in widgets.

## Getting Started

### Prerequisites

Ensure you have [Rust](https://www.rust-lang.org/tools/install) installed.

### Installation

Add `iced` to your `Cargo.toml` dependencies:

```toml
[dependencies]
iced = "0.14" # Check crates.io for the latest version
```

If you want to use specific renderers or features, you can enable them:

```toml
[dependencies]
iced = { version = "0.14", features = ["wgpu", "canvas", "advanced", "svg", "image", "qr_code", "markdown", "highlighter"] }
```

## The Elm Architecture

Iced follows The Elm Architecture, which separates your application into four distinct parts:

1.  **State**: The data that describes your application at a given point in time.
2.  **Messages**: Enums representing user interactions or events (e.g., `ButtonPressed`, `TextChanged`).
3.  **View Logic**: A function that turns your **State** into a visual interface (Widgets). It produces **Messages** when users interact with it.
4.  **Update Logic**: A function that takes a **Message** and the current **State**, and updates the **State**.

## Your First Application: Counter

Let's build a simple counter application to understand how these pieces fit together.

### 1. Define the State

First, describe the state of your application. For a counter, we just need an integer.

```rust
use iced::widget::{button, column, text, Column};
use iced::Center;

#[derive(Default)]
struct Counter {
    value: i64,
}
```

### 2. Define Messages

Next, define the possible interactions. The user can increment or decrement the counter.

```rust
#[derive(Debug, Clone, Copy)]
enum Message {
    Increment,
    Decrement,
}
```

### 3. Implement View Logic

Now, define how the UI looks based on the state. We'll use a `Column` to stack a button, the value text, and another button.

```rust
impl Counter {
    fn view(&self) -> Column<'_, Message> {
        column![
            button("Increment").on_press(Message::Increment),
            text(self.value).size(50),
            button("Decrement").on_press(Message::Decrement),
        ]
        .padding(20)
        .align_x(Center)
    }
}
```

### 4. Implement Update Logic

Define how the state changes in response to messages.

```rust
impl Counter {
    fn update(&mut self, message: Message) {
        match message {
            Message::Increment => {
                self.value += 1;
            }
            Message::Decrement => {
                self.value -= 1;
            }
        }
    }
}
```

### 5. Run the Application

Finally, wire everything together using `iced::run`. The function takes the `update` and `view` functions, and your state type must implement `Default`.

```rust
pub fn main() -> iced::Result {
    iced::run(Counter::update, Counter::view)
}
```

For more control over your application (title, theme, subscriptions), use the `iced::application` builder:

```rust
pub fn main() -> iced::Result {
    iced::application(Counter::default, Counter::update, Counter::view)
        .title("Counter")
        .run()
}
```

## Widgets

Iced provides a wide variety of widgets. All widgets are available in the `iced::widget` module.

### Common Inputs

#### Button

A generic widget that produces a message when pressed.

**API:**

- `new(content: impl Into<Element>) -> Self`
- `on_press(message: Message) -> Self`
- `on_press_maybe(message: Option<Message>) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `height(height: impl Into<Length>) -> Self`
- `padding(padding: impl Into<Padding>) -> Self`
- `clip(clip: bool) -> Self`
- `style(f: impl Fn(&Theme, Status) -> Style) -> Self`

```rust
button("Click Me").on_press(Message::ButtonPressed)
```

#### TextInput

A field that can be filled with text.

**API:**

- `text_input(placeholder: &str, value: &str) -> Self`
- `id(id: impl Into<Id>) -> Self` - For focusing with operations
- `on_input(f: impl Fn(String) -> Message) -> Self`
- `on_submit(message: Message) -> Self`
- `on_paste(f: impl Fn(String) -> Message) -> Self`
- `secure(is_secure: bool) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `padding(padding: impl Into<Padding>) -> Self`
- `size(size: impl Into<Pixels>) -> Self`
- `line_height(line_height: impl Into<LineHeight>) -> Self`
- `align_x(alignment: impl Into<Horizontal>) -> Self`
- `icon(icon: Icon) -> Self`
- `font(font: impl Into<Font>) -> Self`
- `style(f: impl Fn(&Theme, Status) -> Style) -> Self`

```rust
text_input("Placeholder", &self.content)
    .id("my-input")
    .on_input(Message::ContentChanged)
    .on_submit(Message::Submit)
    .padding(15)
    .size(20)
```

**Focus Operations:**

```rust
use iced::widget::operation;

// Focus a specific input by id
operation::focus("my-input")

// Focus next/previous focusable widget
operation::focus_next()
operation::focus_previous()

// Select all text in input
operation::select_all("my-input")
```

#### Checkbox

A box that can be checked.

**API:**

- `checkbox(is_checked: bool) -> Self`
- `label(label: impl IntoFragment) -> Self`
- `on_toggle(f: impl Fn(bool) -> Message) -> Self`
- `on_toggle_maybe(f: Option<impl Fn(bool) -> Message>) -> Self`
- `size(size: impl Into<Pixels>) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `spacing(spacing: impl Into<Pixels>) -> Self`
- `text_size(size: impl Into<Pixels>) -> Self`
- `text_shaping(shaping: Shaping) -> Self`
- `font(font: impl Into<Font>) -> Self`
- `icon(icon: Icon) -> Self`
- `style(f: impl Fn(&Theme, Status) -> Style) -> Self`

**Built-in Styles:**

- `checkbox::primary` - Primary color
- `checkbox::secondary` - Secondary color
- `checkbox::success` - Success (green)
- `checkbox::danger` - Danger (red)

```rust
checkbox(self.is_enabled)
    .label("Enable feature")
    .on_toggle(Message::Toggled)

// With built-in style
checkbox(self.accepted)
    .label("I accept")
    .on_toggle(Message::Accepted)
    .style(checkbox::success)
```

#### Radio

Radio buttons let users choose a single option from a bunch of options.

**API:**

- `new(label: impl Into<String>, value: V, selected: Option<V>, on_click: impl FnOnce(V) -> Message) -> Self`
- `size(size: impl Into<Pixels>) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `spacing(spacing: impl Into<Pixels>) -> Self`
- `text_size(size: impl Into<Pixels>) -> Self`
- `text_line_height(line_height: impl Into<LineHeight>) -> Self`
- `font(font: impl Into<Font>) -> Self`
- `style(f: impl Fn(&Theme, Status) -> Style) -> Self`

```rust
let a = radio("Option A", Choice::A, state.selection, Message::Selected);
let b = radio("Option B", Choice::B, state.selection, Message::Selected);

column![a, b]
```

#### Toggler

A switch/toggle control for binary choices.

**API:**

- `new(is_toggled: bool) -> Self`
- `label(label: impl IntoFragment) -> Self`
- `on_toggle(f: impl Fn(bool) -> Message) -> Self`
- `on_toggle_maybe(f: Option<impl Fn(bool) -> Message>) -> Self`
- `size(size: impl Into<Pixels>) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `text_size(size: impl Into<Pixels>) -> Self`
- `spacing(spacing: impl Into<Pixels>) -> Self`
- `font(font: impl Into<Font>) -> Self`
- `style(f: impl Fn(&Theme, Status) -> Style) -> Self`

```rust
toggler(self.is_enabled)
    .label("Dark Mode")
    .on_toggle(Message::DarkModeToggled)
```

#### Slider

A horizontal bar and a handle that selects a single value from a range.

**API:**

- `slider(range: RangeInclusive<T>, value: T, on_change: impl Fn(T) -> Message) -> Self`
- `default(default: impl Into<T>) -> Self` - Value when double-clicked
- `on_release(message: Message) -> Self`
- `step(step: T) -> Self`
- `shift_step(shift_step: impl Into<T>) -> Self` - Step when shift is held
- `width(width: impl Into<Length>) -> Self`
- `height(height: impl Into<Pixels>) -> Self`
- `style(f: impl Fn(&Theme, Status) -> Style) -> Self`

```rust
slider(1..=100, self.value, Message::ValueChanged)
    .default(50)
    .shift_step(5)
```

#### VerticalSlider

A vertical slider for selecting values from a range.

**API:**

- `vertical_slider(range: RangeInclusive<T>, value: T, on_change: impl Fn(T) -> Message) -> Self`
- `default(default: impl Into<T>) -> Self` - Value when double-clicked
- `on_release(message: Message) -> Self`
- `step(step: T) -> Self`
- `shift_step(shift_step: impl Into<T>) -> Self` - Step when shift is held
- `width(width: impl Into<Pixels>) -> Self`
- `height(height: impl Into<Length>) -> Self`
- `style(f: impl Fn(&Theme, Status) -> Style) -> Self`

```rust
vertical_slider(1..=100, self.volume, Message::VolumeChanged)
    .default(50)
    .shift_step(5)
    .height(200)
```

#### PickList

Select an option from a dropdown list.

**API:**

- `new(options: impl Borrow<[T]>, selected: Option<V>, on_select: impl Fn(T) -> Message) -> Self`
- `placeholder(placeholder: impl Into<String>) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `padding(padding: impl Into<Padding>) -> Self`
- `text_size(size: impl Into<Pixels>) -> Self`
- `font(font: impl Into<Font>) -> Self`
- `handle(handle: Handle) -> Self`
- `style(f: impl Fn(&Theme, Status) -> Style) -> Self`

```rust
pick_list(&self.options, self.selected, Message::Selected)
    .placeholder("Choose an option...")
```

#### ComboBox

A searchable dropdown list of options.

**API:**

- `new(state: &State<T>, placeholder: &str, selection: Option<&T>, on_selected: impl Fn(T) -> Message) -> Self`
- `on_input(f: impl Fn(String) -> Message) -> Self`
- `on_option_hovered(f: impl Fn(T) -> Message) -> Self`
- `on_open(message: Message) -> Self`
- `on_close(message: Message) -> Self`
- `padding(padding: impl Into<Padding>) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `size(size: impl Into<Pixels>) -> Self`
- `font(font: Font) -> Self`
- `icon(icon: Icon) -> Self`
- `menu_height(height: impl Into<Length>) -> Self`
- `input_style(f: impl Fn(&Theme, Status) -> Style) -> Self`
- `menu_style(f: impl Fn(&Theme) -> Style) -> Self`

```rust
// First, create a State in your application state
struct State {
    fruits: combo_box::State<Fruit>,
    favorite: Option<Fruit>,
}

// Then use the combo_box
combo_box(
    &state.fruits,
    "Select your favorite fruit...",
    state.favorite.as_ref(),
    Message::FruitSelected
)
```

### Layout & Containers

#### Column

Arranges children vertically.

**API:**

- `new() -> Self`
- `with_children(children: impl IntoIterator<Item = Element>) -> Self`
- `push(child: impl Into<Element>) -> Self`
- `push_maybe(child: Option<impl Into<Element>>) -> Self`
- `extend(children: impl IntoIterator<Item = Element>) -> Self`
- `spacing(amount: impl Into<Pixels>) -> Self`
- `padding(padding: impl Into<Padding>) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `height(height: impl Into<Length>) -> Self`
- `align_x(alignment: impl Into<Horizontal>) -> Self`
- `clip(clip: bool) -> Self`

```rust
column![
    text("Item 1"),
    text("Item 2"),
    text("Item 3"),
]
.spacing(10)
.padding(20)
```

#### Row

Arranges children horizontally.

**API:**

- `new() -> Self`
- `with_children(children: impl IntoIterator<Item = Element>) -> Self`
- `push(child: impl Into<Element>) -> Self`
- `push_maybe(child: Option<impl Into<Element>>) -> Self`
- `extend(children: impl IntoIterator<Item = Element>) -> Self`
- `spacing(amount: impl Into<Pixels>) -> Self`
- `padding(padding: impl Into<Padding>) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `height(height: impl Into<Length>) -> Self`
- `align_y(alignment: impl Into<Vertical>) -> Self`
- `clip(clip: bool) -> Self`

```rust
row![
    button("Left"),
    text("Center"),
    button("Right"),
]
.spacing(10)
```

#### Container

Wraps a single widget to provide padding, alignment, and styling.

**API:**

- `new(content: impl Into<Element>) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `height(height: impl Into<Length>) -> Self`
- `max_width(max_width: impl Into<Pixels>) -> Self`
- `max_height(max_height: impl Into<Pixels>) -> Self`
- `padding(padding: impl Into<Padding>) -> Self`
- `center(length: impl Into<Length>) -> Self`
- `center_x(width: impl Into<Length>) -> Self`
- `center_y(height: impl Into<Length>) -> Self`
- `align_left(width: impl Into<Length>) -> Self`
- `align_right(width: impl Into<Length>) -> Self`
- `align_top(height: impl Into<Length>) -> Self`
- `align_bottom(height: impl Into<Length>) -> Self`
- `clip(clip: bool) -> Self`
- `style(f: impl Fn(&Theme) -> Style) -> Self`

```rust
container(text("Content"))
    .center(Length::Fill)
    .style(container::rounded_box)
```

**Helper Functions:**

```rust
// Center content in all available space
center(content)

// Center content horizontally
center_x(content)

// Center content vertically
center_y(content)

// Align content to the right
right(content)

// Align content to the bottom
bottom(content)
```

#### Stack

Displays children on top of each other in layers.

**API:**

- `new() -> Self`
- `with_children(children: impl IntoIterator<Item = Element>) -> Self`
- `push(child: impl Into<Element>) -> Self`
- `push_under(child: impl Into<Element>) -> Self`
- `extend(children: impl IntoIterator<Item = Element>) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `height(height: impl Into<Length>) -> Self`
- `clip(clip: bool) -> Self`

```rust
stack![
    image("background.png"),
    container(text("Overlay")).center(Fill),
]
```

#### Grid

A responsive grid layout that distributes content in cells.

**API:**

- `new() -> Self`
- `with_children(children: impl IntoIterator<Item = Element>) -> Self`
- `push(child: impl Into<Element>) -> Self`
- `push_maybe(child: Option<impl Into<Element>>) -> Self`
- `extend(children: impl IntoIterator<Item = Element>) -> Self`
- `spacing(amount: impl Into<Pixels>) -> Self`
- `width(width: impl Into<Pixels>) -> Self`
- `height(height: impl Into<Sizing>) -> Self`
- `columns(columns: usize) -> Self`
- `fluid(max_width: impl Into<Pixels>) -> Self`

```rust
grid![
    text("Cell 1"),
    text("Cell 2"),
    text("Cell 3"),
    text("Cell 4"),
]
.columns(2)
.spacing(10)
```

#### Scrollable

Allows content to scroll if it overflows.

**API:**

- `new(content: impl Into<Element>) -> Self`
- `direction(direction: impl Into<Direction>) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `height(height: impl Into<Length>) -> Self`
- `on_scroll(f: impl Fn(Viewport) -> Message) -> Self`
- `spacing(spacing: impl Into<Pixels>) -> Self`
- `anchor_x(anchor: Anchor) -> Self`
- `anchor_y(anchor: Anchor) -> Self`
- `style(f: impl Fn(&Theme, Status) -> Style) -> Self`

**Direction Options:**

- `Direction::Vertical(Scrollbar)` - Vertical scrolling only
- `Direction::Horizontal(Scrollbar)` - Horizontal scrolling only
- `Direction::Both { vertical, horizontal }` - Both directions

```rust
scrollable(
    column![
        text("Item 1"),
        // ... many items
    ]
)
.height(Length::Fill)
```

#### PaneGrid

A tiling window manager-style layout for splitting regions.

**API:**

- `new(state: &State<T>, view: impl Fn(Pane, &T, bool) -> Content) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `height(height: impl Into<Length>) -> Self`
- `spacing(spacing: impl Into<Pixels>) -> Self`
- `min_size(min_size: impl Into<Pixels>) -> Self`
- `on_click(f: impl Fn(Pane) -> Message) -> Self`
- `on_drag(f: impl Fn(DragEvent) -> Message) -> Self`
- `on_resize(leeway: impl Into<Pixels>, f: impl Fn(ResizeEvent) -> Message) -> Self`
- `style(f: impl Fn(&Theme) -> Style) -> Self`

```rust
pane_grid(&state.panes, |pane, pane_state, is_maximized| {
    pane_grid::Content::new(match pane_state {
        PaneType::Editor => text_editor(&editor_content),
        PaneType::Preview => text("Preview"),
    })
})
.on_drag(Message::PaneDragged)
.on_resize(10, Message::PaneResized)
```

#### Table

A grid-like display of data with columns and rows.

**API:**

- `table(columns: impl IntoIterator<Item = Column>, rows: impl IntoIterator<Item = T>) -> Self`
- `column(header: impl Into<Element>, view: impl Fn(T) -> Element) -> Column`
- `width(width: impl Into<Length>) -> Self`
- `padding(padding: impl Into<Pixels>) -> Self`
- `padding_x(padding: impl Into<Pixels>) -> Self`
- `padding_y(padding: impl Into<Pixels>) -> Self`
- `separator(separator: impl Into<Pixels>) -> Self`
- `separator_x(separator: impl Into<Pixels>) -> Self`
- `separator_y(separator: impl Into<Pixels>) -> Self`

**Column API:**

- `width(width: impl Into<Length>) -> Self`
- `align_x(alignment: impl Into<Horizontal>) -> Self`
- `align_y(alignment: impl Into<Vertical>) -> Self`

```rust
use iced::widget::table::{table, column};

table(
    [
        column("Name", |person: &Person| text(&person.name).into()),
        column("Age", |person: &Person| text(person.age.to_string()).into()),
    ],
    &people,
)
.padding(10)
```

#### Float

Displays content in a floating layer above other content.

**API:**

- `new(content: impl Into<Element>) -> Self`
- `offset(offset: impl Into<Vector>) -> Self`
- `anchor(anchor: Anchor) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `height(height: impl Into<Length>) -> Self`
- `style(f: impl Fn(&Theme) -> Style) -> Self`

```rust
float(button("Floating Button"))
    .anchor(float::Anchor::SouthEast)
    .offset([20, 20])
```

#### Pin

Positions content at fixed coordinates inside its boundaries.

**API:**

- `new(content: impl Into<Element>) -> Self`
- `x(x: impl Into<Pixels>) -> Self`
- `y(y: impl Into<Pixels>) -> Self`
- `position(position: impl Into<Point>) -> Self`

```rust
pin(text("Fixed Position"))
    .x(100)
    .y(50)
```

### Display

#### Text

Displays immutable text.

**API:**

- `new(content: impl IntoFragment) -> Self`
- `size(size: impl Into<Pixels>) -> Self`
- `color(color: impl Into<Color>) -> Self`
- `font(font: impl Into<Font>) -> Self`
- `line_height(line_height: impl Into<LineHeight>) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `height(height: impl Into<Length>) -> Self`
- `align_x(alignment: impl Into<Horizontal>) -> Self`
- `align_y(alignment: impl Into<Vertical>) -> Self`
- `shaping(shaping: Shaping) -> Self`
- `wrapping(wrapping: Wrapping) -> Self`
- `style(f: impl Fn(&Theme) -> Style) -> Self`

```rust
text("Hello World")
    .size(24)
    .color(Color::from_rgb(0.0, 0.0, 1.0))
```

#### Rich Text

Displays text with multiple styled spans.

**API:**

- `rich_text(spans: impl AsRef<[Span]>) -> Rich`
- `span(text: impl IntoFragment) -> Span`

**Span API:**

- `color(color: impl Into<Color>) -> Self`
- `color_maybe(color: Option<impl Into<Color>>) -> Self`
- `font(font: impl Into<Font>) -> Self`
- `size(size: impl Into<Pixels>) -> Self`
- `line_height(line_height: impl Into<LineHeight>) -> Self`
- `underline(underline: bool) -> Self`
- `strikethrough(strikethrough: bool) -> Self`
- `link(link: impl Into<Link>) -> Self`
- `background(background: impl Into<Background>) -> Self`
- `border(border: impl Into<Border>) -> Self`
- `padding(padding: impl Into<Padding>) -> Self`

```rust
rich_text![
    span("I am red!").color(color!(0xff0000)),
    span(" "),
    span("And I am bold!").font(Font { weight: font::Weight::Bold, ..Font::default() }),
]
.on_link_click(Message::LinkClicked)
.size(20)
```

#### Image

Displays a raster image (PNG, JPG, etc.).

**API:**

- `new(handle: impl Into<Handle>) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `height(height: impl Into<Length>) -> Self`
- `content_fit(fit: ContentFit) -> Self`
- `filter_method(filter: FilterMethod) -> Self`
- `rotation(rotation: impl Into<Rotation>) -> Self`
- `opacity(opacity: impl Into<f32>) -> Self`

```rust
image("path/to/image.png")
    .width(200)
    .content_fit(ContentFit::Cover)
```

#### Svg

Displays scalable vector graphics.

**API:**

- `new(handle: impl Into<Handle>) -> Self`
- `from_path(path: impl Into<PathBuf>) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `height(height: impl Into<Length>) -> Self`
- `content_fit(fit: ContentFit) -> Self`
- `rotation(rotation: impl Into<Rotation>) -> Self`
- `opacity(opacity: impl Into<f32>) -> Self`
- `style(f: impl Fn(&Theme, Status) -> Style) -> Self`

```rust
svg("icon.svg")
    .width(32)
    .height(32)
```

#### ProgressBar

Visualizes the progression of an operation.

**API:**

- `new(range: RangeInclusive<f32>, value: f32) -> Self`
- `length(length: impl Into<Length>) -> Self`
- `girth(girth: impl Into<Length>) -> Self`
- `vertical() -> Self`
- `style(f: impl Fn(&Theme) -> Style) -> Self`

**Built-in Styles:**

- `progress_bar::primary` - Primary color
- `progress_bar::secondary` - Secondary color
- `progress_bar::success` - Success (green)
- `progress_bar::warning` - Warning (yellow)
- `progress_bar::danger` - Danger (red)

```rust
progress_bar(0.0..=100.0, self.progress)
    .style(progress_bar::success)
```

#### Rule

A horizontal or vertical line for dividing content.

**API:**

- `rule::horizontal(height: impl Into<Pixels>) -> Rule`
- `rule::vertical(width: impl Into<Pixels>) -> Rule`
- `style(f: impl Fn(&Theme) -> Style) -> Self`

```rust
column![
    text("Section 1"),
    rule::horizontal(2),
    text("Section 2"),
]
```

#### Tooltip

Displays a hint when hovering over content.

**API:**

- `new(content: impl Into<Element>, tooltip: impl Into<Element>, position: Position) -> Self`
- `gap(gap: impl Into<Pixels>) -> Self`
- `padding(padding: impl Into<Pixels>) -> Self`
- `delay(delay: Duration) -> Self`
- `snap_within_viewport(snap: bool) -> Self`
- `style(f: impl Fn(&Theme) -> Style) -> Self`

**Position Options:**

- `Position::Top`
- `Position::Bottom`
- `Position::Left`
- `Position::Right`
- `Position::FollowCursor`

```rust
tooltip(
    button("Hover me!"),
    container("This is a tooltip!")
        .padding(10)
        .style(container::rounded_box),
    tooltip::Position::Bottom,
)
```

#### QRCode

Displays a QR code from data.

**API:**

- `new(data: &Data) -> Self`
- `cell_size(size: impl Into<Pixels>) -> Self`
- `total_size(size: impl Into<Pixels>) -> Self`
- `style(f: impl Fn(&Theme) -> Style) -> Self`

**Data Creation:**

- `Data::new(data: impl AsRef<[u8]>) -> Result<Data, Error>`
- `Data::with_error_correction(data: impl AsRef<[u8]>, ec: ErrorCorrection) -> Result<Data, Error>`

```rust
// Create QR code data
let data = qr_code::Data::new("https://iced.rs").unwrap();

// Display it
qr_code(&data).cell_size(5)
```

#### Markdown

Parses and displays Markdown content.

**API:**

- `markdown::parse(markdown: &str) -> impl Iterator<Item = Item>`
- `markdown::view(items: impl IntoIterator<Item = &Item>, settings: impl Into<Settings>) -> Element`
- `markdown::Content::new() -> Content`
- `markdown::Content::parse(markdown: &str) -> Content`
- `content.push_str(markdown: &str)` - Incremental parsing
- `content.items() -> &[Item]`
- `content.images() -> &HashSet<Uri>`

```rust
// Parse markdown once
let items: Vec<markdown::Item> = markdown::parse("# Hello\n**Bold** text").collect();

// Display it
markdown::view(&items, Theme::Dark)
    .map(Message::LinkClicked)
```

### Complex Inputs

#### TextEditor

A multi-line text editor with syntax highlighting support.

**API:**

- `text_editor(content: &Content) -> Self`
- `id(id: impl Into<Id>) -> Self` - For focusing with operations
- `placeholder(placeholder: impl text::IntoFragment) -> Self`
- `on_action(f: impl Fn(Action) -> Message) -> Self`
- `font(font: impl Into<Font>) -> Self`
- `size(size: impl Into<Pixels>) -> Self`
- `line_height(line_height: impl Into<LineHeight>) -> Self`
- `height(height: impl Into<Length>) -> Self`
- `padding(padding: impl Into<Padding>) -> Self`
- `wrapping(wrapping: Wrapping) -> Self`
- `highlight(extension: &str, theme: highlighter::Theme) -> Self` - Requires `highlighter` feature
- `key_binding(f: impl Fn(&KeyPress) -> Option<Binding>) -> Self` - Custom key bindings
- `style(f: impl Fn(&Theme, Status) -> Style) -> Self`

**Content API:**

- `Content::new() -> Content`
- `Content::with_text(text: &str) -> Content`
- `content.perform(action: Action)` - Apply editor action
- `content.text() -> String` - Get all text
- `content.line(index: usize) -> Option<&str>` - Get line
- `content.line_count() -> usize` - Number of lines
- `content.selection() -> Option<String>` - Get selected text
- `content.cursor() -> Cursor` - Get cursor info (line, column)
- `content.line_ending() -> Option<LineEnding>` - Detected line ending

```rust
text_editor(&self.content)
    .id("editor")
    .height(Fill)
    .on_action(Message::EditorAction)
    .wrapping(text::Wrapping::Word)
    .highlight("rs", highlighter::Theme::SolarizedDark)
    .key_binding(|key_press| {
        // Custom Ctrl+S binding
        match key_press.key.as_ref() {
            keyboard::Key::Character("s")
                if key_press.modifiers.command() =>
            {
                Some(text_editor::Binding::Custom(Message::SaveFile))
            }
            _ => text_editor::Binding::from_key_press(key_press),
        }
    })
```

### Utility Widgets

#### Space

Adds empty spacing between elements.

**API:**

- `Space::new() -> Self`
- `space::horizontal() -> Space` - Fill horizontal space
- `space::vertical() -> Space` - Fill vertical space
- `width(width: impl Into<Length>) -> Self`
- `height(height: impl Into<Length>) -> Self`

```rust
row![
    text("Left"),
    space::horizontal(), // Pushes "Right" to the edge
    text("Right"),
]
```

#### MouseArea

Captures mouse events on its content.

**API:**

- `new(content: impl Into<Element>) -> Self`
- `on_press(message: Message) -> Self`
- `on_release(message: Message) -> Self`
- `on_double_click(message: Message) -> Self`
- `on_right_press(message: Message) -> Self`
- `on_right_release(message: Message) -> Self`
- `on_middle_press(message: Message) -> Self`
- `on_middle_release(message: Message) -> Self`
- `on_scroll(f: impl Fn(ScrollDelta) -> Message) -> Self`
- `on_enter(message: Message) -> Self`
- `on_move(f: impl Fn(Point) -> Message) -> Self`
- `on_exit(message: Message) -> Self`
- `interaction(interaction: mouse::Interaction) -> Self`

```rust
mouse_area(text("Click or right-click me!"))
    .on_press(Message::LeftClick)
    .on_right_press(Message::RightClick)
    .on_enter(Message::MouseEntered)
    .on_exit(Message::MouseExited)
```

#### Responsive

A widget that adapts its content based on available space.

**API:**

- `new(view: impl Fn(Size) -> Element) -> Self`
- `width(width: impl Into<Length>) -> Self`
- `height(height: impl Into<Length>) -> Self`

```rust
responsive(|size| {
    if size.width > 600.0 {
        row![sidebar(), main_content()].into()
    } else {
        column![main_content()].into()
    }
})
```

#### Sensor

Detects visibility and size changes.

**API:**

- `new(content: impl Into<Element>) -> Self`
- `on_show(f: impl Fn() -> Message) -> Self`
- `on_hide(f: impl Fn() -> Message) -> Self`
- `on_resize(f: impl Fn(Size) -> Message) -> Self`
- `at_distance(distance: impl Into<Pixels>) -> Self`

```rust
sensor(image_placeholder())
    .on_show(Message::LoadImage)
    .at_distance(100) // Trigger 100px before visible
```

#### Themer

Applies a custom theme to its contents.

**API:**

- `new(theme: Option<Theme>, content: impl Into<Element>) -> Self`

```rust
themer(
    Some(Theme::Dark),
    container(text("Always dark!"))
)
```

#### Keyed Column

A column that maintains widget state based on keys (for dynamic lists).

**API:**

- `keyed_column(children: impl IntoIterator<Item = (Key, Element)>) -> KeyedColumn`

```rust
keyed_column(
    items.iter().map(|item| {
        (item.id, item_view(item).into())
    })
)
```

## Core Concepts

### Layout & Positioning

Iced uses a flexible layout system based on `Length`:

- **`Length::Shrink`**: Fits the content size.
- **`Length::Fill`**: Fills available space.
- **`Length::Fixed(f32)`**: Exact size in pixels.
- **`Length::FillPortion(u16)`**: Weighted distribution in `Row`/`Column`.

### Async Actions (Tasks)

Your `update` function can _optionally_ return a `Task`. This allows you to perform asynchronous operations like HTTP requests, file I/O, or timers without freezing the UI.

```rust
use iced::Task;

fn update(&mut self, message: Message) -> Task<Message> {
    match message {
        Message::LoadData => Task::perform(fetch_data(), Message::DataLoaded),
        Message::DataLoaded(data) => {
            self.data = data;
            Task::none()
        }
    }
}

async fn fetch_data() -> Data {
    // Async operation
}
```

**Task Utilities:**

```rust
// Do nothing
Task::none()

// Perform an async operation
Task::perform(future, |result| Message::from(result))

// Run a stream
Task::run(stream, |item| Message::from(item))

// Batch multiple tasks
Task::batch([task1, task2, task3])

// Chain tasks
task1.chain(|result| task2)

// Map task result
task.map(Message::from)

// Make a task abortable
let (task, handle) = task.abortable();
// Later: handle.abort();
```

**Built-in Operations:**

```rust
use iced::widget::operation;

// Focus operations
operation::focus("widget-id")
operation::focus_next()
operation::focus_previous()
operation::select_all("input-id")

// Scrollable operations
operation::snap_to("scrollable-id", scrollable::RelativeOffset::START)
operation::scroll_to("scrollable-id", scrollable::AbsoluteOffset { x: 0.0, y: 100.0 })
```

### Subscriptions

Subscriptions allow your application to listen to external events continuously (keyboard, mouse, window resizing, time). To use subscriptions, you must use the `iced::application` builder:

```rust
pub fn main() -> iced::Result {
    iced::application(App::default, App::update, App::view)
        .subscription(App::subscription)
        .run()
}

impl App {
    fn subscription(&self) -> Subscription<Message> {
        use iced::keyboard;
        use iced::time;
        use std::time::Duration;

        Subscription::batch([
            // Listen for keyboard events
            keyboard::listen().filter_map(|event| {
                match event {
                    keyboard::Event::KeyPressed { key, .. } => {
                        Some(Message::KeyPressed(key))
                    }
                    _ => None,
                }
            }),
            // Timer subscription
            time::every(Duration::from_secs(1)).map(Message::Tick),
        ])
    }
}
```

For listening to all runtime events:

```rust
use iced::event;

fn subscription(&self) -> Subscription<Message> {
    event::listen().map(Message::EventOccurred)
}
```

## Advanced Styling & Theming

Iced uses a `Theme` enum for global styling. You can pick from built-in themes or define your own.

### Built-in Themes

- `Theme::Light`
- `Theme::Dark`
- `Theme::Dracula`
- `Theme::Nord`
- `Theme::SolarizedLight`
- `Theme::SolarizedDark`
- `Theme::GruvboxLight`
- `Theme::GruvboxDark`
- `Theme::CatppuccinLatte`
- `Theme::CatppuccinFrappe`
- `Theme::CatppuccinMacchiato`
- `Theme::CatppuccinMocha`
- `Theme::TokyoNight`
- `Theme::TokyoNightStorm`
- `Theme::TokyoNightLight`
- `Theme::KanagawaWave`
- `Theme::KanagawaDragon`
- `Theme::KanagawaLotus`
- `Theme::Moonfly`
- `Theme::Nightfly`
- `Theme::Oxocarbon`
- `Theme::Ferra`

### Built-in Styles

Most widgets come with style constructors that take the current theme:

```rust
button("Delete").style(button::danger)
button("Primary").style(button::primary)
button("Secondary").style(button::secondary)
button("Text-only").style(button::text)
```

### Custom Styling

To create custom styles, define a function that returns a style struct based on the `Theme` and widget `Status`.

```rust
fn custom_button_style(theme: &Theme, status: button::Status) -> button::Style {
    let palette = theme.extended_palette();

    match status {
        button::Status::Active => button::Style {
            background: Some(palette.primary.base.color.into()),
            text_color: palette.primary.base.text,
            border: Border::default().rounded(8),
            ..Default::default()
        },
        button::Status::Hovered => button::Style {
            background: Some(palette.primary.strong.color.into()),
            text_color: palette.primary.strong.text,
            border: Border::default().rounded(8),
            ..Default::default()
        },
        _ => button::Style::default(),
    }
}

// Usage
button("Custom").style(custom_button_style)
```

## Advanced Graphics

### Canvas

For custom 2D vector graphics, use the `Canvas` widget. You must implement the `canvas::Program` trait.

```rust
use iced::widget::canvas;
use iced::{mouse, Color, Rectangle, Renderer, Theme};

struct MyProgram;

impl canvas::Program<Message> for MyProgram {
    type State = ();

    fn draw(
        &self,
        _state: &(),
        renderer: &Renderer,
        _theme: &Theme,
        bounds: Rectangle,
        _cursor: mouse::Cursor
    ) -> Vec<canvas::Geometry> {
        let mut frame = canvas::Frame::new(renderer, bounds.size());

        // Draw a circle
        let circle = canvas::Path::circle(frame.center(), 50.0);
        frame.fill(&circle, Color::from_rgb(0.2, 0.5, 0.8));

        // Draw a line
        let line = canvas::Path::line(
            Point::new(0.0, 0.0),
            Point::new(bounds.width, bounds.height)
        );
        frame.stroke(&line, canvas::Stroke::default().with_width(2.0));

        vec![frame.into_geometry()]
    }
}

// In view:
canvas(MyProgram)
    .width(Length::Fill)
    .height(Length::Fill)
```

### Shaders

For maximum performance or custom GPU effects, use the `shader` widget (requires `wgpu` feature). You write custom WGSL shaders.

```rust
use iced::widget::shader;

struct MyShader {
    // shader state
}

impl shader::Program<Message> for MyShader {
    type State = ();
    type Primitive = MyPrimitive;

    fn draw(
        &self,
        _state: &Self::State,
        _cursor: mouse::Cursor,
        bounds: Rectangle,
    ) -> Self::Primitive {
        MyPrimitive { bounds }
    }
}

// In view:
shader(my_shader).width(400).height(400)
```

See `examples/custom_shader` for a complete example.

## Custom Widgets

If built-in widgets aren't enough, you can implement the `Widget` trait directly.

Key methods to implement:

- **`size`**: Return the widget's width and height.
- **`layout`**: Calculate layout nodes for the widget and its children.
- **`draw`**: Issue drawing commands to the renderer.
- **`update`**: Handle events and update internal state.
- **`mouse_interaction`**: Define cursor changes (e.g., grab, pointer).

See `examples/custom_widget` for a complete boilerplate.

## Performance Optimization

### `lazy`

The `lazy` widget caches the widget tree and only rebuilds it if the input data changes.

```rust
use iced::widget::lazy;

// Only re-renders if 'self.items' changes (based on hash/eq)
lazy(&self.items, |items| view_large_list(items))
```

### `keyed_column`

For dynamic lists where items are added/removed frequently, use `keyed_column` to preserve widget state.

```rust
use iced::widget::keyed_column;

keyed_column(
    self.items.iter().map(|item| {
        (item.id, item_view(item).into())
    })
)
```

### `responsive`

Use `responsive` to conditionally render different layouts based on available space, avoiding unnecessary widget creation.

```rust
responsive(|size| {
    if size.width > 800.0 {
        desktop_layout()
    } else {
        mobile_layout()
    }
})
```

## Application Lifecycle & Windowing

### Multi-Window

Use `iced::daemon` for advanced control, including managing multiple windows.

```rust
fn main() -> iced::Result {
    iced::daemon(App::new, App::update, App::view).run()
}
```

Messages for window management:

- `window::open(settings)`: Spawns a new window.
- `window::close(id)`: Closes a specific window.
- `window::resize(id, size)`: Resizes a window programmatically.
- `window::move_to(id, position)`: Moves a window.
- `window::maximize(id, bool)`: Maximize/restore a window.
- `window::minimize(id, bool)`: Minimize a window.

### Application Exit

To exit the application gracefully, call `iced::exit()`, which returns a `Task` that closes the loop.

```rust
Message::Exit => iced::exit()
```

## Web Deployment

Iced supports compiling to WebAssembly (WASM).

1.  Install the target: `rustup target add wasm32-unknown-unknown`.
2.  Use a tool like `trunk` to bundle your app.
3.  Ensure your `Task`s are compatible with WASM (e.g., use `reqwest` with `json` feature for fetch, avoid blocking IO).

```bash
trunk build --release
trunk serve
```

## Testing & Debugging

### Debug Overlay

You can enable a debug overlay to inspect widget boundaries and performance metrics. This is often a feature flag or a runtime setting depending on the specific Iced version/renderer setup.

### Testing

Since `update` functions are pure (State + Message -> State + Task), they are easy to unit test.

```rust
#[test]
fn test_increment() {
    let mut counter = Counter::default();
    counter.update(Message::Increment);
    assert_eq!(counter.value, 1);
}
```

For integration testing (simulating user interaction), use `iced_test` or structure your logic to decouple it from the view entirely.

### Logging

Use the `log` crate with `env_logger` for debugging:

```rust
fn main() -> iced::Result {
    env_logger::init();
    iced::run("My App", App::update, App::view)
}
```

Run with: `RUST_LOG=debug cargo run`
